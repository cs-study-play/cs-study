# 카프카(Kafka)



# 아파치 카프카(Apache kafka)
![Untitled](https://user-images.githubusercontent.com/97663140/167441499-780fe027-1d0a-40dd-90da-ce091e0a9029.png)

아파치 카프카는 링크드인(LinkedIn)에서 처음 개발된 분산 메시징 시스템이다.

### *메시징 시스템?

- MSA(마이크로서비스 아키텍처)에서 사용하는 데이터 송수신 방법.
- 메시징 시스템은 Kafka, RabbitMQ, Active MQ 등이 있음.
- MSA에서는 시스템 간의 호출이 많기 때문에 서비스간의 결합도를 낮추기 위해서 등 여러가지 장점에 의해 메시징 시스템을 이용하고 있음.

## Publish/Subscribe (펍/섭) 시스템

- 카프카는 기본적으로 **Publish-Subscribe 모델**을 구현한 분산 메시징 시스템
- 데이터를 만들어내는 프로듀서(Producer, 생산자), 소비하는 컨슈머(Consumer, 소비자) 그리고 이 둘 사이에서 중재자 역할을 하는 브로커(Broker)로 결합된 느슨한 결합(Loosely Coupled)의 시스템
- 프로듀서는 브로커를 통해 메시지를 발행(Publish)
    - 메시지를 전달할 대상을 명시하지 않음, 관련 메시지를 구독(Subscribe)할 컨슈머가 브로커에게 요청하여 가져감
    - 신문사에서 신문을 발행하면 읽을 사람들이 자발적으로 읽어가는 형태를 생각하면 됨.
- 프로듀서는 특정 토픽(Topic)으로 메시지를 발행 가능
    - 컨슈머 역시 특정 토픽의 메시지를 읽어갈 수 있음 (토픽이 만나는 지점)
- 카프카 클러스터로 메시지를 전송할 수 있는 프로듀서와 카프카로부터 메시지를 읽어갈 수 있는 컨슈머 클라이언트 API를 제공

## 카프카의 특징

1. 다중 프로듀서, 다중 컨슈머
    - 카프카의 토픽에 여러 프로듀서가 동시에 메시지를 전송 가능.
    - 카프카 토픽의 메시지를 여러 컨슈머들이 동시에 읽기 가능.
    - 하나의 프로듀서가 여러 토픽에 메시지를 보내거나, 하나의 컨슈머가 여러 토픽에서 메시지를 읽을 수 있음
        
        ⇒ 카프카의 큰 강점 
        
2. 파일시스템에 저장
    - 전통적인 메시징 시스템은 프로듀서가 전송한 메시지를 브로커의 메모리 상에 존재하는 큐(Queue)에 유지, 컨슈머가 메시지 읽으면 메시지 삭제 ...
    - 카프카는 메시지를 브로커가 위치한 서버의 파일 시스템에 저장
        - 컨슈머는 프로듀서가 생성한 메시지를 바로 소비하지 않아도 되고 메시지를 보존하고 있는 기간 내에는 언제든지 읽어갈 수 있다
        
        ⇒ 이는 프로듀서와 컨슈머의 속도 차이가 있을 때 유용.
        
        ⇒ 또한 컨슈머들이 데이터를 모았다가 처리하는 배치(batch) 처리를 가능
        
3. 확장성
    - 카프카 클러스터는 운영 중에 확장이 용이하도록 설계, 운영 중에 시스템 트래픽이 높아지면 브로커를 추가해서 클러스터 확장 가능.
        
        ⇒ 수평적인 확장(Horizontally Scale, Scale out)
        
    - 프로듀서, 컨슈머도 증가 가능
    - 토픽은 내부에서 파티션(Partition)이라는 세분화된 단위로 나뉘어 저장, 파티션 개수도 운영 중에 추가 가능
    
    ⇒ 아무튼 확장성이 좋다는 의미.
    
4. 고성능
    - 카프카는 실시간 로그 처리에 특화. 높은 처리량을 갖도록 설계.

![Untitled 1](https://user-images.githubusercontent.com/97663140/167441461-acef0f81-0351-4b8c-aa42-1fd59e3e5cd9.png)
![Untitled 2](https://user-images.githubusercontent.com/97663140/167441486-cdcf69c8-814b-491c-9ee4-835d1224cd8e.png)
    
논문 : Kafka: a Distributed Messaging System for Log Processing
    
5. 컨슈머의 pull 방식
    - 기존의 메시징 시스템의 경우 브로커가 컨슈머에게 메시지를 전달해주는 **Push 방식**을 채택한 경우가 많았음.
    - 카프카는 컨슈머가 브로커에게서 메세지를 가져오는 **Pull 방식** 채택
        - 컨슈머의 처리량을 브로커가 고민할 필요 X
        - 컨슈머는 자신이 처리할 수 있는 만큼의 메시지만 브로커에게서 가져가면 되기 때문에 최적의 메시지처리 성능 가짐.
        - 메시지를 모았다가 한번에 처리할 수 있는 배치처리도 간단하게 구현할 수 있음.


참고 : https://soft.plusblog.co.kr/3
